#include "CRC16.h"
#include "OPVCobsDecoder.h"
#include "cobs.h"

#include <gtest/gtest.h>

#include <algorithm>
#include <cstdint>
#include <stdlib.h>

using namespace mobilinkd;

int received_count;

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}


class OPVCobsDecoderRandomTest : public ::testing::Test {
 protected:

  OPVCobsDecoder cobs_decoder;

  void SetUp() override
  {
    cobs_decoder.set_packet_callback(random_packet_callback);
  }

  // void TearDown() override {}

  static const int max_cobs_packet_len = mobilinkd::ip_mtu + std::ceil(mobilinkd::ip_mtu / 254.0);
  static const int frame_bytes = mobilinkd::stream_frame_payload_bytes;
  static const int crc_length = 2;

  //static int received_count;

  int frame_count = 0;

  // CRC16 a packet of length bytes and append the result
  static void append_crc16(const uint8_t *buf, int data_len)
  {
    mobilinkd::CRC16<0x5935, 0xFFFF> crc;

    crc.reset();
    for (int i=0; i < data_len; i++)
    {
      crc(buf[i]);
    }
    * (uint16_t *)(buf+data_len) = crc.get();
  }


  // Create a random packet. Return its length.
  int make_random_packet(uint8_t *buf, int serial)
  {
    // start the packet with the specified serial number
      * (uint16_t *)buf = serial; // two-byte serial number field

    // pick a random packet length (don't worry too much about bias)
    int random_length = minimum_packet_length + std::rand()%(mobilinkd::ip_mtu - minimum_packet_length);
  
    // fill the body of the packet with random data (ditto on bias)
    for (int i = 2; i < random_length-crc_length; i++)
    {
      buf[i] = std::rand()%0x100;
    }
    
    // end the packet with a CRC of the above
    append_crc16(buf, random_length-crc_length);

    return(random_length);
  }


  // Check a random packet generated by the above function.
  static void check_random_packet(const uint8_t *buf, int len, int expected_serial)
  {
    std::cerr << "Checking packet " << expected_serial << " of length " << len << std::endl;

    uint16_t received_serial = *(uint16_t *)buf;
    EXPECT_EQ(received_serial, expected_serial) << "Serial# " << received_serial << " is not " << expected_serial;

    uint16_t received_crc = *(uint16_t *)(buf+len-crc_length);
    append_crc16(buf, len-crc_length);
    uint16_t expected_crc = *(uint16_t *)(buf+len-crc_length);
    EXPECT_EQ(received_crc, expected_crc) << "CRC " << received_crc << " is not " << expected_crc;
  }


  // COBS-encode a packet and add it to the big buffer (with zero separator)
  int cobs_and_append_packet(uint8_t *buf, uint8_t *packet, int packet_len)
  {

    cobs_encode_result result = cobs_encode(buf, max_cobs_packet_len, packet, packet_len);
    if (result.status != COBS_ENCODE_OK)
    {
        return 0;
    }
    buf[result.out_len] = 0;  // separator
    return result.out_len + 1;
  }


  void send_a_bunch_of_packets(int target_serial)
  {
      int serial = 0;
      int bytes_remaining = 0;
      uint8_t buf[max_cobs_packet_len + frame_bytes];
      uint8_t *next_bytes = buf;    // pointer into buf to next bytes to send

      while (1)
      {
          if (bytes_remaining >= frame_bytes)
          {
              // we still have at least a frame's worth ready. Send it.
              // std::cerr << bytes_remaining << " bytes remaining; sending " << frame_bytes << " bytes" << std::endl;
              cobs_decoder.process_cobs_data(next_bytes, frame_bytes);
              frame_count++;
              bytes_remaining -= frame_bytes;
              next_bytes += frame_bytes;
          }
          else if (bytes_remaining > 0 && next_bytes != buf)
          {
              // move less than a frame of remaining bytes to the start of the buffer
              // std::cerr << "Moving " << bytes_remaining << " bytes to start of buffer" << std::endl;
              memmove(buf, next_bytes, bytes_remaining);   // memmove handles overlapping ranges; memcpy might not.
              next_bytes = buf;
          }
          else if (serial == target_serial+1)
          {
              // we've created enough packets; fill this frame with zero bytes
              memset(buf+bytes_remaining, 0, frame_bytes - bytes_remaining);
              bytes_remaining = frame_bytes;
              serial++;
          }
          else if (serial >= target_serial+2)
          {
              // we've sent all packets and some zeroes, we're done.
              break;
          }
          else
          {
              // we have less than a frame, already at the start of the buffer, and not done yet.
              // Let's add a new packet to the stream.
              uint8_t packet[mobilinkd::ip_mtu];
              int packet_len = make_random_packet(packet, serial++);
              // std::cerr << "Random packet length = " << packet_len << std::endl;
              int added_len = cobs_and_append_packet(buf+bytes_remaining, packet, packet_len);
              ASSERT_NE(added_len, 0) << "COBS encode failure";
              if (bytes_remaining == 0)
              {
                next_bytes = buf;
              }
              bytes_remaining += added_len;
              // std::cerr << "Added " << added_len << " bytes to buffer; now " << bytes_remaining << " remaining." << std::endl;
          }
      }
  }


  static void random_packet_callback(const uint8_t *packet, int packet_len)
  {
      check_random_packet(packet, packet_len, received_count++);
  }
};

TEST_F(OPVCobsDecoderRandomTest, many_random_packets)
{
    const int target_packet_count = 1000;

    cobs_decoder.set_packet_callback(random_packet_callback);
    cobs_decoder.reset();

    received_count = 0;

    send_a_bunch_of_packets(target_packet_count);

    EXPECT_EQ(received_count-1, target_packet_count);

    std::cerr << "Tested " << target_packet_count << " packets in " << frame_count << " frames." << std::endl;
}
